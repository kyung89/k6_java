package com.ruby.java.ch05;

import java.util.Random;

/*
 * 클래스 메소드 구현 실습 목적
 */
class Matrix {
	int rows;
	int cols;
	int[] data;
	
	public Matrix(int rows, int cols) {
		this.rows = rows; 
		this.cols = cols;
		data = new int[rows * cols];
	}
	
	void getData() {
		// 난수로 입력
		Random rnd = new Random();
		int RND_MAX = 20;

		for(int idx = 0; idx < this.rows * this.cols; idx++)
			this.data[idx] = rnd.nextInt(RND_MAX);		
	}
	
	Matrix addMatrix(Matrix b) {
		Matrix m = new Matrix(this.rows, this.cols);
		
		for(int idx = 0; idx < this.rows * this.cols; idx++)
				m.data[idx] = this.data[idx] + b.data[idx];
		
		return m;
	}
	
	// this.data를 int[][] 배열로 변환하는 메서드
	int[][] convertDataToMatrix() {
		int[][] matrix = new int[this.rows][this.cols];
		
		int idx = 0;
		for(int i = 0; i < this.rows; i++) 
			for(int j = 0; j < this.cols; j++) 
				matrix[i][j] = this.data[idx++];
		
		return matrix;
	}
	
	Matrix multiplyMatrix(Matrix b) {
		Matrix m = new Matrix(this.rows, b.cols);
		
		// this.data * b 계산
		
		// this.data -> int[][] 배열로 변환
		int[][] this_data = this.convertDataToMatrix();

		// b -> int[][] 배열로 변환
		int[][] b_data = b.convertDataToMatrix();
		
		// 행렬의 곱 계산
		int[][] result = new int[this.rows][b.cols];
		for(int i = 0; i < this.rows; i++)
			for(int j = 0; j < b.cols; j++)
				for(int k = 0; k <this.cols; k++)
					result[i][j] += this_data[i][k] * b_data[k][j];
		
		// int[][] 행렬 -> this.data		
		int idx = 0;
		for(int[] row : result)
			for(int col : row) 
				m.data[idx++] = col;
		
		return m;	
	}
	
	Matrix transposeMatrix() {
		Matrix m = new Matrix(this.cols, this.rows); // B[rows = 3][cols = 4] ->  F[cols = 4][rows = 3]
		
		// 또 다른 방법
// 		for(int idx = 0; idx < this.rows * this.cols; idx++)
// 			m.data[idx] = this.data[cols * (idx % rows) + (idx / rows)];
 		
 		int[][] matrix = new int[this.cols][this.rows];
 		int[][] this_data = this.convertDataToMatrix();
 		
 		for(int i = 0; i < this.rows; i++)
 			for(int j = 0; j < this.cols; j++)
 				matrix[j][i] = this_data[i][j];
 		
 		// int[][] 행렬 -> this.data		
 		int idx = 0;
 		for(int[] row : matrix)
 			for(int col : row) 
 				m.data[idx++] = col;
		
		return m;
	}
	
	void showMatrix(String str) {
		System.out.println(str);
		// 2차원 배열 모양으로 출력하는 코드 작성

		// 검증 코드
		// for(int item : this.data) System.out.println(item);
		// System.out.println();
		
		for(int idx = 0; idx < this.rows * this.cols; idx++) {
			System.out.print(this.data[idx] + "\t");
			if(idx % cols == cols - 1) System.out.println();
		}
		System.out.println();
	}
}

public class Test_행렬클래스 {

	// ch04 Test_행렬연산: 클래스 버전
	public static void main(String[] args) {
		/*
		 * 난수 생성으로 초기화
		 * A[3][4] = B[3][4] + C[3][4]; 
		 * D[3][5] = B[3][4] * E[4][5];
		 * F[4][3] = B[3][4]의 전치 행렬
		 */
	
		Matrix B = new Matrix(3,4);
		Matrix C = new Matrix(3,4);
		Matrix A, D, F;
		Matrix E = new Matrix(4,5);
		
		System.out.println();

		System.out.println("행렬 더하기: A[3][4] = B[3][4] + C[3][4]");
		B.getData();C.getData();E.getData();
		
		System.out.println();
		
		A = B.addMatrix(C);
		B.showMatrix("B[3][4]");C.showMatrix("C[3][4]");A.showMatrix("A[3][4]");
		
		System.out.println("행렬 곱하기: D[3][5] = B[3][4] * E[4][5]");		
		System.out.println();
		
		D = B.multiplyMatrix(E);
		B.showMatrix("B[3][4]");E.showMatrix("E[4][5]");D.showMatrix("D[3][5]");
		
		System.out.println("행렬 전치: F[4][3] = B[3][4]의 전치 행렬");		
		System.out.println();
		
		F = B.transposeMatrix();
		B.showMatrix("B[3][4]");F.showMatrix("F[4][3]");
		
	}

}